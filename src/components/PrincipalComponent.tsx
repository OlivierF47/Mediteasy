import { useState, useRef, useEffect } from 'react';
import { FilePicker } from '@capawesome/capacitor-file-picker';
import { Filesystem, Directory } from '@capacitor/filesystem';
import './PrincipalComponent.css'

interface SoundOption {
  value: string;
  label: string;
  file?: string;
  isCustom?: boolean;
}

/* --------------------------------------------
  Donn√©es statiques : sons, gongs, intervalles, dur√©es
-------------------------------------------- */

const soundOptions: SoundOption[] = [
  { value: 'silence', label: 'üîá Silence' },
  { value: 'rain', label: 'üåßÔ∏è Pluie', file: '/assets/ambients/rain.mp3' },
  { value: 'ocean', label: 'üåä Ocean', file: '/assets/ambients/ocean.mp3' },
];

const gongOptions = [
  { id: 'gong1', name: 'Gong Japonais', file: '/assets/gongs/studio_gong.wav' },
  { id: 'gong2', name: 'Gong Zen', file: '/assets/gongs/zen_gong.wav' },
  { id: 'gong3', name: 'Bol Tib√©tain', file: '/assets/gongs/tibetian_bowl.mp3' },
  { id: 'gong4', name: 'Bol en cristal', file: '/assets/gongs/crystal_bowl.mp3' },
];

const intervalOptions = [
  { value: 0, label: 'Aucun' },
  { value: 5, label: 'Toutes les 5 min' },
  { value: 10, label: 'Toutes les 10 min' },
  { value: 15, label: 'Toutes les 15 min' },
  { value: 30, label: 'Toutes les 30 min' },
];

const durationOptions = [
  { value: 5, label: '5 min' },
  { value: 10, label: '10 min' },
  { value: 15, label: '15 min' },
  { value: 20, label: '20 min' },
  { value: 30, label: '30 min' },
  { value: 45, label: '45 min' },
  { value: 60, label: '60 min' },
];

/* --------------------------------------------
  Composant principal : MeditationTimer
-------------------------------------------- */

export default function MeditationTimer() {

  /* -------------------------
    √âtats de l'application
  -------------------------- */

  const [selectedSound, setSelectedSound] = useState('silence');
  const [duration, setDuration] = useState(10);
  const [customMinutes, setCustomMinutes] = useState('');
  const [showCustomInput, setShowCustomInput] = useState(false);
  const [isPlaying, setIsPlaying] = useState(false);
  const [isPaused, setIsPaused] = useState(false);
  const [isFinished, setIsFinished] = useState(false);
  const [volume, setVolume] = useState(0.5);
  const [gongVolume, setGongVolume] = useState(0.7);
  const [selectedGong, setSelectedGong] = useState('gong1');
  const [gongInterval, setGongInterval] = useState(0);
  const [gongMoments, setGongMoments] = useState({ start: false, end: false });
  const [timeRemaining, setTimeRemaining] = useState(0);
  const [nextGongIn, setNextGongIn] = useState(0);
  const [customSounds, setCustomSounds] = useState<SoundOption[]>([]);
  const [preparationTime, setPreparationTime] = useState(0);
  const [isPreparing, setIsPreparing] = useState(false);

  const ambientAudioRef = useRef<HTMLAudioElement | null>(null);
  const gongAudioRef = useRef<HTMLAudioElement | null>(null);
  const timerRef = useRef<NodeJS.Timeout | null>(null);
  const gongTimerRef = useRef<NodeJS.Timeout | null>(null);
  const preparationTimerRef = useRef<NodeJS.Timeout | null>(null);

  /* -------------------------
    S√©lections actuelles
  -------------------------- */

  // Charger les sons personnalis√©s au d√©marrage
  useEffect(() => {
    const loadCustomSounds = async () => {
      try {
        const result = await Filesystem.readFile({
          path: 'custom-sounds.json',
          directory: Directory.Data,
        });

        if (result && typeof result.data === 'string') {
          const savedSounds = JSON.parse(result.data);
          setCustomSounds(savedSounds);
        } else {
          setCustomSounds([]); // Aucun son sauvegard√©
        }
      } catch (error) {
        console.error('Erreur lors du chargement des sons personnalis√©s :', error);
        setCustomSounds([]); // Aucun son sauvegard√©
      }
    };
    loadCustomSounds();
  }, []);

  // Sauvegarder les sons personnalis√©s
  const saveCustomSounds = async (sounds: SoundOption[]) => {
    await Filesystem.writeFile({
      path: 'custom-sounds.json',
      data: JSON.stringify(sounds),
      directory: Directory.Data,
    });
  };

  // Ajouter un son personnalis√©
  const addCustomSound = async () => {
    try {
      const result = await FilePicker.pickFiles({
        types: ['audio/*'],
        readData: true,
      });

      if (!result.files[0]) {
        console.log('Aucun fichier s√©lectionn√©');
        return;
      }

      const file = result.files[0];
      const soundId = `custom_${Date.now()}`;
      const fileName = `${soundId}.${file.name.split('.').pop()}`;
      const soundName = file.name.replace(/\.[^/.]+$/, ""); // Nom sans extension

      // Sauvegarder le fichier dans le syst√®me de fichiers
      await Filesystem.writeFile({
        path: `audio/${fileName}`,
        data: file.data ?? '',
        directory: Directory.Data,
      });

      // Cr√©er l'objet son personnalis√©
      const newCustomSound: SoundOption = {
        value: soundId,
        label: `üéµ ${soundName}`,
        file: `audio/${fileName}`,
        isCustom: true
      };

      // Mettre √† jour la liste des sons personnalis√©s
      const updatedCustomSounds = [...customSounds, newCustomSound];
      setCustomSounds(updatedCustomSounds);
      
      // Sauvegarder dans le stockage persistant
      await saveCustomSounds(updatedCustomSounds);

      // S√©lectionner automatiquement le nouveau son
      setSelectedSound(soundId);

      console.log(`Son ajout√© et s√©lectionn√© : ${soundName}`);
    } catch (error) {
      console.error('Erreur lors de la s√©lection ou de la sauvegarde du fichier :', error);
    }
  };

  // Supprimer un son personnalis√©
  const removeCustomSound = async (soundId: string) => {
    try {
      // Trouver le son √† supprimer
      const soundToRemove = customSounds.find(sound => sound.value === soundId);
      if (!soundToRemove) return;

      // Supprimer le fichier audio du syst√®me de fichiers
      if (soundToRemove.file) {
        try {
          await Filesystem.deleteFile({
            path: soundToRemove.file,
            directory: Directory.Data,
          });
        } catch (error) {
          console.warn('Impossible de supprimer le fichier audio:', error);
        }
      }

      // Mettre √† jour la liste des sons personnalis√©s
      const updatedCustomSounds = customSounds.filter(sound => sound.value !== soundId);
      setCustomSounds(updatedCustomSounds);
      
      // Sauvegarder dans le stockage persistant
      await saveCustomSounds(updatedCustomSounds);

      // Si le son supprim√© √©tait s√©lectionn√©, revenir au silence
      if (selectedSound === soundId) {
        setSelectedSound('silence');
      }

      console.log(`Son supprim√© : ${soundToRemove.label}`);
    } catch (error) {
      console.error('Erreur lors de la suppression du son personnalis√© :', error);
    }
  };

  const allSounds = [...soundOptions, ...customSounds];
  const selectedSoundOption = allSounds.find((s) => s.value === selectedSound);
  const selectedGongOption = gongOptions.find((g) => g.id === selectedGong);

  /* -------------------------
    Pr√©visualisation des sons
  -------------------------- */

  useEffect(() => {
    if (!isPlaying && !isPaused && selectedSound !== 'silence' && ambientAudioRef.current) {
      ambientAudioRef.current.currentTime = 0;
      ambientAudioRef.current.volume = volume;
      ambientAudioRef.current.play().catch((err) => console.error('Erreur preview:', err));
      
      const previewTimer = setTimeout(() => {
        if (ambientAudioRef.current) {
          ambientAudioRef.current.pause();
          ambientAudioRef.current.currentTime = 0;
        }
      }, 5000);
      
      return () => clearTimeout(previewTimer);
    }
  }, [selectedSound, isPlaying, isPaused]);

  useEffect(() => {
    if (!isPlaying && !isPaused && gongAudioRef.current) {
      gongAudioRef.current.currentTime = 0;
      gongAudioRef.current.volume = gongVolume;
      gongAudioRef.current.play().catch((err) => console.error('Erreur preview gong:', err));
    }
  }, [selectedGong, isPlaying, isPaused]);

  /* -------------------------
    Effets pour ajuster les volumes en temps r√©el
  -------------------------- */

  useEffect(() => {
    if (ambientAudioRef.current) {
      ambientAudioRef.current.volume = volume;
    }
  }, [volume]);

  useEffect(() => {
    if (gongAudioRef.current) {
      gongAudioRef.current.volume = gongVolume;
    }
  }, [gongVolume]);

  /* -------------------------
    Fonction pour jouer le gong
  -------------------------- */

  const playGong = () => {
    if (gongAudioRef.current) {
      gongAudioRef.current.currentTime = 0;
      gongAudioRef.current.play().catch((err) => console.error('Erreur gong:', err));
    }
  };

  /* -------------------------
    Formatage du temps
  -------------------------- */

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  /* -------------------------
    Lancer la m√©ditation
  -------------------------- */

  const handlePlay = () => {
    // D√©marrer la phase de pr√©paration
    setIsPreparing(true);
    setPreparationTime(10); // 10 secondes de pr√©paration

    let prepTime = 10;
    preparationTimerRef.current = setInterval(() => {
      prepTime--;
      setPreparationTime(prepTime);

      if (prepTime <= 0) {
        if (preparationTimerRef.current) {
          clearInterval(preparationTimerRef.current);
        }
        setIsPreparing(false);
        startMeditation();
      }
    }, 1000);
  };

  const startMeditation = () => {
    setIsPlaying(true);
    setIsPaused(false);
    setIsFinished(false);
    const totalSeconds = duration * 60;
    setTimeRemaining(totalSeconds);
    setNextGongIn(gongInterval > 0 ? gongInterval * 60 : 0);

    // Gong de d√©but (si activ√©)
    if (gongMoments.start) {
      setTimeout(() => playGong(), 500);
    }

    // Lecture du son ambiant
    if (selectedSound !== 'silence' && ambientAudioRef.current) {
      ambientAudioRef.current.currentTime = 0;
      ambientAudioRef.current.volume = volume;
      ambientAudioRef.current.play().catch((err) => console.error('Erreur audio:', err));
    }

    // Timer principal (compte √† rebours)
    let remaining = totalSeconds;
    timerRef.current = setInterval(() => {
      remaining--;
      setTimeRemaining(remaining);

      // Fin du timer
      if (remaining <= 0) {
        handleStop();
        setIsFinished(true);
        // Gong de fin si activ√©
        if (gongMoments.end) {
          playGong();
        }
      }
    }, 1000);

    // Timer des gongs (intervalles r√©guliers)
    if (gongInterval > 0) {
      let nextGong = gongInterval * 60;
      setNextGongIn(nextGong);
      
      gongTimerRef.current = setInterval(() => {
        nextGong--;
        setNextGongIn(nextGong);
        
        if (nextGong <= 0 && remaining > 0) {
          playGong();
          nextGong = gongInterval * 60;
          setNextGongIn(nextGong);
        }
      }, 1000);
    }
  };

  /* -------------------------
    Pause de la m√©ditation
  -------------------------- */

  const handlePause = () => {
    setIsPlaying(false);
    setIsPaused(true);

    if (ambientAudioRef.current) {
      ambientAudioRef.current.pause();
    }
    if (timerRef.current) {
      clearInterval(timerRef.current);
    }
    if (gongTimerRef.current) {
      clearInterval(gongTimerRef.current);
    }
  };

  /* -------------------------
    Reprise de la m√©ditation
  -------------------------- */

  const handleResume = () => {
    setIsPlaying(true);
    setIsPaused(false);

    if (ambientAudioRef.current) {
      ambientAudioRef.current.play();
    }

    // Relancer le timer principal avec le temps restant
    let remaining = timeRemaining;
    timerRef.current = setInterval(() => {
      remaining--;
      setTimeRemaining(remaining);

      if (remaining <= 0) {
        handleStop();
        setIsFinished(true);
        if (gongMoments.end) {
          playGong();
        }
      }
    }, 1000);

    // Relancer le timer des gongs si n√©cessaire
    if (gongInterval > 0) {
      let nextGong = nextGongIn;
      gongTimerRef.current = setInterval(() => {
        nextGong--;
        setNextGongIn(nextGong);

        if (nextGong <= 0 && remaining > 0) {
          playGong();
          nextGong = gongInterval * 60;
          setNextGongIn(nextGong);
        }
      }, 1000);
    }
  };

  /* -------------------------
    Arr√™t de la m√©ditation
  -------------------------- */

  const handleStop = () => {
    setIsPlaying(false);
    setIsPaused(false);

    if (ambientAudioRef.current) {
      ambientAudioRef.current.pause();
      ambientAudioRef.current.currentTime = 0;
    }
    if (timerRef.current) {
      clearInterval(timerRef.current);
    }
    if (gongTimerRef.current) {
      clearInterval(gongTimerRef.current);
    }
    setTimeRemaining(0);
    setNextGongIn(0);
  };

  /* -------------------------
    Gestion de la dur√©e personnalis√©e
  -------------------------- */

  const handleAddCustomDuration = () => {
    const minutes = parseInt(customMinutes, 10);
    if (!isNaN(minutes) && minutes >= 1 && minutes <= 180) {
      setDuration(minutes);
      setShowCustomInput(false);
      setCustomMinutes('');
    }
  };

  /* -------------------------
    Interface utilisateur (UI)
  -------------------------- */

  return (
    <div className="app">
      <div className="container">

        {/* Titre principal */}
        <h1 className="title-main">üßò Mediteasy</h1>


        {/* Fichiers audio cach√©s */}
        {selectedSound !== 'silence' && selectedSoundOption?.file && (
          <audio
            ref={ambientAudioRef}
            loop
            preload="auto"
            src={selectedSoundOption.file}
          />
        )}

        {selectedGongOption && (
          <audio
            ref={gongAudioRef}
            preload="auto"
            src={selectedGongOption.file}
          />
        )}

        {/* Phase de pr√©paration */}
        {isPreparing && (
          <div className="section">
            <div className="time-display">{preparationTime}</div>
            <div className="text-muted">üßò Pr√©parez-vous...</div>
          </div>
        )}

        {/* Affichage pendant la m√©ditation ou en pause */}
        {(isPlaying || isPaused) && (
          <div className="section">
            <div className="time-display">{formatTime(timeRemaining)}</div>
            <div className="text-muted">
              {isPaused ? '‚è∏Ô∏è En pause' : 'Temps restant'}
            </div>
            {gongInterval > 0 && nextGongIn > 0 && !isPaused && (
              <div className="text-muted">
                üîî Prochain gong dans {formatTime(nextGongIn)}
              </div>
            )}
          </div>
        )}

        {/* Configuration avant d√©marrage */}
        {!isPlaying && !isPaused && !isFinished && !isPreparing && (
          <>
            {/* Son ambiant */}
            <div className="section compact">
              <div className="control-row">
                <span className="control-icon">üéµ</span>
                <select
                  value={selectedSound}
                  onChange={(e) => {
                    const value = e.target.value;
                    if(value === "custom"){
                      e.target.value = selectedSound;
                      addCustomSound();
                    } else {
                      setSelectedSound(value);
                    }
                  }}
                  className="select compact"
                >
                  {soundOptions.map((s) => (
                    <option key={s.value} value={s.value}>
                      {s.label}
                    </option>
                  ))}
                  {customSounds.map((s) =>(
                    <option key={s.value} value={s.value}>
                      {s.label}
                    </option>
                  ))}
                  <option value="custom">‚¨áÔ∏è Ajouter un son personnalis√©</option>
                </select>
                {selectedSoundOption?.isCustom && (
                  <button 
                    onClick={() => removeCustomSound(selectedSound)} 
                    className="btn-delete"
                    title="Supprimer ce son"
                  >
                    <img src="/assets/images/trash.svg" alt="Supprimer" />
                  </button>
                )}
              </div>

              {selectedSound !== 'silence' && (
                <div className="volume-control">
                  <input
                    type="range"
                    min="0"
                    max="1"
                    step="0.01"
                    value={volume}
                    onChange={(e) => setVolume(parseFloat(e.target.value))}
                    className="range compact"
                  />
                  <span className="volume-label">{Math.round(volume * 100)}%</span>
                </div>
              )}
            </div>

            {/* Gong de m√©ditation */}
            <div className="section compact">
              <div className="control-row">
                <span className="control-icon">üîî</span>
                <select
                  value={selectedGong}
                  onChange={(e) => setSelectedGong(e.target.value)}
                  className="select compact"
                >
                  {gongOptions.map((g) => (
                    <option key={g.id} value={g.id}>
                      {g.name}
                    </option>
                  ))}
                </select>
              </div>

              <div className="volume-control">
                <input
                  type="range"
                  min="0"
                  max="1"
                  step="0.01"
                  value={gongVolume}
                  onChange={(e) => setGongVolume(parseFloat(e.target.value))}
                  className="range compact"
                />
                <span className="volume-label">{Math.round(gongVolume * 100)}%</span>
              </div>

              <div className="control-row">
                <span className="control-icon">‚è±Ô∏è</span>
                <select
                  value={gongInterval}
                  onChange={(e) => setGongInterval(parseInt(e.target.value))}
                  className="select compact"
                >
                  {intervalOptions.map((opt) => (
                    <option key={opt.value} value={opt.value}>
                      {opt.label}
                    </option>
                  ))}
                </select>
              </div>

              <div className="checkbox-row">
                <label className="checkbox compact">
                  <input
                    type="checkbox"
                    checked={gongMoments.start}
                    onChange={(e) =>
                      setGongMoments({ ...gongMoments, start: e.target.checked })
                    }
                  />
                  üîî D√©but
                </label>
                <label className="checkbox compact">
                  <input
                    type="checkbox"
                    checked={gongMoments.end}
                    onChange={(e) =>
                      setGongMoments({ ...gongMoments, end: e.target.checked })
                    }
                  />
                  üîî Fin
                </label>
              </div>
            </div>

            {/* Dur√©e de m√©ditation */}
            <div className="section compact">
              <div className="control-row">
                <span className="control-icon">‚è≥</span>
                <select
                  value={duration}
                  onChange={(e) => setDuration(parseInt(e.target.value))}
                  className="select compact"
                >
                  {durationOptions.map((d) => (
                    <option key={d.value} value={d.value}>
                      {d.label}
                    </option>
                  ))}
                </select>
              </div>

              {!showCustomInput ? (
                <button
                  onClick={() => setShowCustomInput(true)}
                  className="btn btn-secondary compact"
                >
                  ‚ûï Personnaliser
                </button>
              ) : (
                <div className="custom-duration">
                  <input
                    type="number"
                    value={customMinutes}
                    onChange={(e) => setCustomMinutes(e.target.value)}
                    placeholder="1-180"
                    min="1"
                    max="180"
                    className="input compact"
                    onKeyPress={(e) => {
                      if (e.key === 'Enter') handleAddCustomDuration();
                    }}
                  />
                  <button onClick={handleAddCustomDuration} className="btn btn-primary compact">
                    ‚úì
                  </button>
                  <button
                    onClick={() => {
                      setShowCustomInput(false);
                      setCustomMinutes('');
                    }}
                    className="btn btn-secondary compact"
                  >
                    ‚úï
                  </button>
                </div>
              )}
            </div>
          </>
        )}

        {/* Boutons D√©marrer / Pause / Reprendre / Stop */}
        <div className="section">
          {!isPlaying && !isPaused && !isPreparing && (
            <button onClick={handlePlay} className="btn btn-primary">
              {isFinished ? 'üîÑ Recommencer' : '‚ñ∂Ô∏è D√©marrer'}
            </button>
          )}
          {isPaused && (
            <button onClick={handleResume} className="btn btn-primary">
              ‚ñ∂Ô∏è Reprendre
            </button>
          )}
          {isPlaying && (
            <>
              <button onClick={handlePause} className="btn btn-secondary">
                ‚è∏Ô∏è Pause
              </button>
              <button onClick={handleStop} className="btn btn-secondary">
                ‚èπÔ∏è Arr√™ter
              </button>
            </>
          )}
          {isPaused && (
            <button onClick={handleStop} className="btn btn-secondary">
              ‚èπÔ∏è Arr√™ter
            </button>
          )}
        </div>

        {/* Fin de session */}
        {isFinished && (
          <div className="section">
            <div className="emoji">‚ú®</div>
            <div className="title-section">M√©ditation termin√©e !</div>
          </div>
        )}
      </div>
    </div>
  );
}